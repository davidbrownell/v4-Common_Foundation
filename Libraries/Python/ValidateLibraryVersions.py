# ----------------------------------------------------------------------
# |
# |  ValidateLibraryVersions.py
# |
# |  David Brownell <db@DavidBrownell.com>
# |      2023-03-03 14:06:13
# |
# ----------------------------------------------------------------------
# |
# |  Copyright David Brownell 2023
# |  Distributed under the Boost Software License, Version 1.0. See
# |  accompanying file LICENSE_1_0.txt or copy at
# |  http://www.boost.org/LICENSE_1_0.txt.
# |
# ----------------------------------------------------------------------
"""Validates that the library versions associated with each python library are set to the expected values."""

import importlib
import sys

from pathlib import Path
from typing import Optional

import typer

from typer.core import TyperGroup

from Common_Foundation.ContextlibEx import ExitStack
from Common_Foundation.Shell.All import CurrentShell
from Common_Foundation.Streams.DoneManager import DoneManager, DoneManagerFlags
from Common_Foundation import SubprocessEx

from Common_FoundationEx.InflectEx import inflect


# For most python libraries, the semantic version will be dynamically generated by AutoSemVer. However,
# this repository is special (because it is used as the foundation for all other repositories) and
# these libraries cannot use that technique because they may be installed BEFORE the environment is
# activated (meaning AutoSemVer is not yet available). So, for this repository, expose functionality
# that can be invoked by the CI machine to ensure that the values are set correctly.
#
# This is the only repository that will need to go through this process.
#
# Note that for consistency, the structure of the version files is consistent with other python
# libraries in other repositories even though the technique to create the version is different
# here than in those libraries.


# ----------------------------------------------------------------------
class NaturalOrderGrouper(TyperGroup):
    # pylint: disable=missing-class-docstring
    # ----------------------------------------------------------------------
    def list_commands(self, *args, **kwargs):  # pylint: disable=unused-argument
        return self.commands.keys()


# ----------------------------------------------------------------------
app                                         = typer.Typer(
    cls=NaturalOrderGrouper,
    help=__doc__,
    no_args_is_help=True,
    pretty_exceptions_show_locals=False,
    pretty_exceptions_enable=False,
)


# ----------------------------------------------------------------------
@app.command("EntryPoint", no_args_is_help=False)
def EntryPoint(
    verbose: bool=typer.Option(False, "--verbose", help="Write verbose information to the terminal."),
    debug: bool=typer.Option(False, "--debug", help="Write debug information to the terminal."),
) -> None:
    """Validates that the versions associated with each python library is the expected value."""

    with DoneManager.CreateCommandLine(
        output_flags=DoneManagerFlags.Create(verbose=verbose, debug=debug),
    ) as dm:
        libraries: list[Path] = []

        with dm.Nested(
            "Calculating libraries...",
            lambda: "{} found".format(inflect.no("library", len(libraries))),
            suffix="\n",
        ) as calculate_dm:
            for child in Path(__file__).parent.iterdir():
                if not child.is_dir():
                    continue

                libraries.append(child)

            if not libraries:
                calculate_dm.WriteError("No libraries were found.")
                return

        with dm.Nested(
            "Evaluating {}...".format(inflect.no("library", len(libraries))),
        ) as evaluate_dm:
            auto_sem_ver_command_line = 'AutoSemVer{ext} Generate --no-branch-name --no-metadata --quiet'.format(
                ext=CurrentShell.script_extensions[0],
            )

            for library_index, library in enumerate(libraries):
                with evaluate_dm.Nested(
                    "'{}' ({} of {})...".format(library.name, library_index + 1, len(libraries)),
                    suffix="\n",
                ) as this_dm:
                    actual_version: Optional[str] = None

                    with this_dm.Nested(
                        "Running AutoSemVer...",
                        lambda: actual_version or "errors were encountered",
                    ) as auto_sem_ver_dm:
                        result = SubprocessEx.Run(
                            auto_sem_ver_command_line,
                            cwd=library,
                        )

                        auto_sem_ver_dm.result = result.returncode

                        if auto_sem_ver_dm.result != 0:
                            auto_sem_ver_dm.WriteError(result.output)
                            continue

                        expected_prefix = "{}-v".format(library.name)

                        result = result.output.strip()

                        if not result.startswith(expected_prefix):
                            dm.WriteError("'{}' does not start with '{}'.".format(result, expected_prefix))
                            continue

                        actual_version = result[len(expected_prefix):]

                    specified_version: Optional[str] = None

                    with this_dm.Nested(
                        "Loading Version...",
                        lambda: specified_version or "errors were encountered",
                    ) as specified_dm:
                        src_dir = library / "src"
                        if not src_dir.is_dir():
                            specified_dm.WriteError("'{}' is not a valid directory.".format(src_dir))
                            continue

                        version_file = src_dir / "__version__.py"
                        if not version_file.is_file():
                            specified_dm.WriteError("'{}' is not a valid filename.".format(version_file))
                            continue

                        sys.path.insert(0, str(version_file.parent))
                        with ExitStack(lambda: sys.path.pop(0)):
                            mod = importlib.import_module(version_file.stem)

                            specified_version = getattr(mod, "VERSION", None)
                            del sys.modules[version_file.stem]

                            if specified_version is None:
                                specified_dm.WriteError("'VERSION' was not defined in '{}'.".format(version_file))
                                continue

                    if specified_version != actual_version:
                        this_dm.WriteError(
                            "The specified version '{}' does not match the actual version '{}'.".format(
                                specified_version,
                                actual_version,
                            ),
                        )
                        continue


# ----------------------------------------------------------------------
# ----------------------------------------------------------------------
# ----------------------------------------------------------------------
if __name__ == "__main__":
    app()
