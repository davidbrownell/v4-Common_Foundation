# ----------------------------------------------------------------------
# |
# |  GitHooks.py
# |
# |  David Brownell <db@DavidBrownell.com>
# |      2022-10-25 08:32:31
# |
# ----------------------------------------------------------------------
# |
# |  Copyright David Brownell 2022-23
# |  Distributed under the Boost Software License, Version 1.0. See
# |  accompanying file LICENSE_1_0.txt or copy at
# |  http://www.boost.org/LICENSE_1_0.txt.
# |
# ----------------------------------------------------------------------
"""Functionality invoked by Git hook scripts"""

import copy
import os
import re
import textwrap
import sys

from contextlib import contextmanager
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Iterator, List, Optional, Union

import typer

from typer.core import TyperGroup

from Common_Foundation.SourceControlManagers.GitSourceControlManager import GitSourceControlManager, Repository
from Common_Foundation.Streams.Capabilities import Capabilities
from Common_Foundation.Streams.DoneManager import DoneManager, DoneManagerFlags
from Common_Foundation import TextwrapEx

from RepositoryBootstrap.DataTypes import ChangeInfo

from . import HookImpl


# ----------------------------------------------------------------------
class NaturalOrderGrouper(TyperGroup):
    # ----------------------------------------------------------------------
    def list_commands(self, *args, **kwargs):  # pylint: disable=unused-argument
        return self.commands.keys()


# ----------------------------------------------------------------------
app                                         = typer.Typer(
    cls=NaturalOrderGrouper,
    no_args_is_help=True,
    pretty_exceptions_show_locals=False,
    pretty_exceptions_enable=False,
)


# ----------------------------------------------------------------------
@app.command("prepare_commit_msg", no_args_is_help=True)
def prepare_commit_msg(
    working_dir: Path=typer.Argument(..., file_okay=False, exists=True, resolve_path=True, help="git working directory."),
    name: str=typer.Argument(..., help="git username."),
    email: str=typer.Argument(..., help="git email."),
    # Note that this filename is not resolved via typer due to the way in which the script is invoked.
    commit_message_file: Path=typer.Argument(..., dir_okay=False, help="File generated by git that contains the commit message."),
    commit_type: Optional[str]=typer.Argument(None, help="Type of commit."),
    extra_data: Optional[str]=typer.Argument(None, help="Extract data sometimes passed to this function, although its usefulness is not entirely clear."),
    verbose: bool=typer.Option(False, "--verbose", help="Write verbose information to the terminal."),
    debug: bool=typer.Option(False, "--debug", help="Write debug information to the terminal."),
) -> None:
    """Functionality invoked before the user is presented with an option to change the commit message."""

    with _YieldCommandLineDoneManager(verbose=verbose, debug=debug) as dm:
        if commit_type is not None and commit_type not in ["message", "commit"]:
            dm.WriteError("'{}' is a commit type not yet seen in the wild.".format(commit_type))

        if commit_type is None:
            calculated_commit_type = ChangeInfo.ChangeType.Squash
        elif commit_type in [
            "message",
            "template",  # I'm not sure why git wants to differentiate between these scenarios, as the contents of commit_message_file have been pre-populated with the contents of the template file
        ]:
            # GitKraken sends this type with a squash when extra_data is not None
            if extra_data is not None:
                calculated_commit_type = ChangeInfo.ChangeType.Squash
            else:
                calculated_commit_type = ChangeInfo.ChangeType.Standard
        elif commit_type == "commit":
            calculated_commit_type = ChangeInfo.ChangeType.Amend
        else:
            assert False, commit_type

        dm.WriteInfo(
            textwrap.dedent(
                """\
                prepare_commit_msg
                ------------------
                commit_message_file:        {}
                commit_type:                {}
                extra_data:                 {}

                calculated_commit_type:     {}

                """,
            ).format(
                commit_message_file,
                commit_type or "None",
                extra_data or "None",
                str(calculated_commit_type),
            ),
        )

        git = GitSourceControlManager()

        repository = git.Open(git.GetRoot(working_dir))
        changes: list[ChangeInfo] = []

        with dm.Nested(
            "Extracting change information...",
            suffix="\n" if dm.is_verbose else "",
        ) as change_dm:
            # Get the message info
            commit_message_file = working_dir / commit_message_file
            assert commit_message_file.is_file(), commit_message_file

            with commit_message_file.open(
                encoding="UTF-8",
            ) as f:
                message_content = f.read()

            message_lines = message_content.split("\n")

            title = message_lines[0]

            if len(message_lines) == 1:
                description = None
            else:
                message_line_index = 1

                if len(message_lines) > (message_line_index + 1) and not message_lines[message_line_index]:
                    message_line_index += 1

                description = "\n".join(message_lines[message_line_index:])

            if calculated_commit_type in [
                ChangeInfo.ChangeType.Standard,
                ChangeInfo.ChangeType.Amend,
            ]:
                # Get the files associated with the working repository
                result = _ParseGitOutput(
                    change_dm,
                    repository.repo_root,
                    "git status --porcelain=1 --untracked-files=no",
                )

                if result is None:
                    assert change_dm.result != 0
                    return

                changes.append(
                    ChangeInfo.Create(
                        ChangeInfo.ChangeType.Standard,
                        "HEAD",
                        title,
                        description,
                        "{} <{}>".format(name, email),
                        datetime.now(),
                        result.files_added or [],
                        result.files_removed or [],
                        result.files_modified or [],
                    ),
                )

                if calculated_commit_type == ChangeInfo.ChangeType.Amend:
                    # Get the info for the change that is being amended
                    result = _CreateChangeInfo(
                        change_dm,
                        repository.repo_root,
                        calculated_commit_type,
                        -1,
                    )

                    if result is None:
                        assert change_dm.result != 0
                        return

                    changes.append(result)

            elif calculated_commit_type == ChangeInfo.ChangeType.Squash:
                # Unfortunately, once we are here, we don't seem to have the necessary context to figure
                # out which changes actually prompted the hook to be fired. Make due as best that we can
                # given the lack of information.
                changes.append(
                    ChangeInfo.Create(
                        calculated_commit_type,
                        "<unknown>",
                        title,
                        description,
                        "{} <{}>".format(name, email),
                        datetime.now(),
                        [],
                        [],
                        [],
                    ),
                )

            else:
                assert False, commit_type  # pragma: no cover

        original_change = copy.deepcopy(changes[0])

        HookImpl.OnCommit(dm, repository, changes)

        # Update the change if necessary
        if changes[0] != original_change:
            if changes[0].title != original_change.title or changes[0].description != original_change.description:
                new_message_content = changes[0].title

                if changes[0].description:
                    new_message_content += "\n\n{}".format(changes[0].description)

                with commit_message_file.open(
                    "w",
                    encoding="UTF-8",
                ) as f:
                    f.write(new_message_content)


# ----------------------------------------------------------------------
@app.command("commit_msg", no_args_is_help=True)
def commit_msg(
    working_dir: Path=typer.Argument(..., file_okay=False, exists=True, resolve_path=True, help="git working directory."),          # pylint: disable=unused-argument
    name: str=typer.Argument(..., help="git username."),                                                                            # pylint: disable=unused-argument
    email: str=typer.Argument(..., help="git email."),                                                                              # pylint: disable=unused-argument
    # Note that this filename is not resolved via typer due to the way in which the script is invoked.                              # pylint: disable=unused-argument
    commit_message_file: Path=typer.Argument(..., dir_okay=False, help="File generated by git that contains the commit message."),  # pylint: disable=unused-argument
    verbose: bool=typer.Option(False, "--verbose", help="Write verbose information to the terminal."),                              # pylint: disable=unused-argument
    debug: bool=typer.Option(False, "--debug", help="Write debug information to the terminal."),                                    # pylint: disable=unused-argument
) -> None:
    """Functionality invoked before a commit is finalized."""

    # This is a noop, as everything can be done in prepare_commit_msg
    return


# ----------------------------------------------------------------------
@app.command("pre_push", no_args_is_help=True)
def pre_push(
    working_dir: Path=typer.Argument(..., file_okay=False, exists=True, resolve_path=True, help="git working directory."),  # pylint: disable=unused-argument
    verbose: bool=typer.Option(False, "--verbose", help="Write verbose information to the terminal."),
    debug: bool=typer.Option(False, "--debug", help="Write debug information to the terminal."),
) -> None:
    """Functionality invoked before a set of changes are pushed to the remote repository."""

    with _YieldCommandLineDoneManager(verbose=verbose, debug=debug) as dm:
        dm.WriteError("Not implemented yet")


# ----------------------------------------------------------------------
@app.command("pre_receive", no_args_is_help=True)
def pre_receive(
    working_dir: Path=typer.Argument(..., file_okay=False, exists=True, resolve_path=True, help="git working directory."),  # pylint: disable=unused-argument
    verbose: bool=typer.Option(False, "--verbose", help="Write verbose information to the terminal."),
    debug: bool=typer.Option(False, "--debug", help="Write debug information to the terminal."),
) -> None:
    """Functionality invoked after a set of changes are received from a remote repository but before they are introduced into the current repository."""

    with _YieldCommandLineDoneManager(verbose=verbose, debug=debug) as dm:
        dm.WriteError("Not implemented yet")


# ----------------------------------------------------------------------
# |
# |  Private Types
# |
# ----------------------------------------------------------------------
@dataclass(frozen=True)
class _ParseGitOutputResultType(object):
    # ----------------------------------------------------------------------
    ignored_lines: Optional[List[str]]
    files_added: Optional[List[Path]]
    files_modified: Optional[List[Path]]
    files_removed: Optional[List[Path]]

    # ----------------------------------------------------------------------
    def __post_init__(self):
        assert self.ignored_lines is None or self.ignored_lines
        assert self.files_added is None or self.files_added
        assert self.files_modified is None or self.files_modified
        assert self.files_removed is None or self.files_removed


# ----------------------------------------------------------------------
# |
# |  Private Functions
# |
# ----------------------------------------------------------------------
@contextmanager
def _YieldCommandLineDoneManager(
    *,
    verbose: bool,
    debug: bool,
) -> Iterator[DoneManager]:
    Capabilities.Create(
        sys.stdout,
        is_headless=False,
        supports_colors=True,
        # Make this look reasonable for most terminals
        columns=140,
        no_column_warning=True,
    )

    with DoneManager.CreateCommandLine(
        output_flags=DoneManagerFlags.Create(verbose=verbose, debug=debug),
    ) as dm:
        yield dm


# ----------------------------------------------------------------------
def _CreateChangeInfo(
    dm: DoneManager,
    repository_root: Path,
    commit_type: ChangeInfo.ChangeType,
    change_id: Union[str, int],
) -> Optional[ChangeInfo]:
    # Ensure that the change id is a string
    if not isinstance(change_id, str):
        result = GitSourceControlManager.Execute(
            "git log {} --format=%H".format(change_id),
            cwd=repository_root,
            strip=True,
        )

        dm.result = result.returncode

        if dm.result != 0:
            dm.WriteError(result.output)
            return None

        change_id = result.output

    result = _ParseGitOutput(
        dm,
        repository_root,
        "git show {} --name-status --no-color".format(change_id),
    )

    if result is None:
        assert dm.result != 0
        return None

    # Extract the rest of the commit info
    assert result.ignored_lines

    tag_value_regex = re.compile(
        r"""(?#
        Start of Line                       )^(?#
        Tag                                 )(?P<tag>\S+):(?#
        Value                               )\s*(?P<value>.+)(?#
        End of Line                         )$(?#
        )""",
    )

    description_regex = re.compile(
        r"""(?#
        Start of Line                       )^(?#
        Initial Whitespace                  )(?P<whitespace>\s+)(?#
        Content                             )(?P<content>\S.*?)(?#
        End of Line                         )$(?#
        )""",
    )

    author: Optional[str] = None
    author_date: Optional[datetime] = None
    title: Optional[str] = None
    description_whitespace_len: Optional[int] = None
    description_lines: List[str] = []
    in_description = False

    for line in result.ignored_lines:
        tag_value_match = tag_value_regex.match(line)
        if tag_value_match:
            tag = tag_value_match.group("tag")
            value = tag_value_match.group("value")

            if tag == "Author":
                assert author is None
                author = value
            if tag == "Date":
                author_date = datetime.strptime(value, "%a %b %d %H:%M:%S %Y %z")

            in_description = False
            continue

        description_match = description_regex.match(line)
        if description_match:
            in_description = True

            whitespace = description_match.group("whitespace")
            content = description_match.group("content")

            if title is None:
                title = content

                assert description_whitespace_len is None
                description_whitespace_len = len(whitespace)
            else:
                description_lines.append(
                    "{}{}".format(
                        whitespace[description_whitespace_len:],
                        content,
                    ),
                )

            continue

        if in_description:
            description_lines.append("")
            continue

    if description_lines and not description_lines[0]:
        description_lines = description_lines[1:]

    assert author is not None
    assert author_date is not None
    assert title is not None

    return ChangeInfo.Create(
        commit_type,
        change_id,
        title,
        "\n".join(description_lines) if description_lines else None,
        author,
        author_date,
        result.files_added or [],
        result.files_removed or [],
        result.files_modified or [],
    )


# ----------------------------------------------------------------------
def _ParseGitOutput(
    dm: DoneManager,
    repository_root: Path,
    command_line: str,
) -> Optional[_ParseGitOutputResultType]:
    result = GitSourceControlManager.Execute(
        command_line,
        cwd=repository_root,
        strip=True,
    )

    dm.result = result.returncode

    if dm.result != 0:
        dm.WriteError(
            textwrap.dedent(
                """\
                {}

                {}
                """,
            ).format(
                command_line,
                TextwrapEx.Indent(result.output, 4),
            ),
        )

        return None

    with dm.YieldVerboseStream() as stream:
        stream.write(
            textwrap.dedent(
                """\
                Command Line: {}

                {}


                """,
            ).format(
                command_line,
                TextwrapEx.Indent(result.output, 4),
            ),
        )

    # Parse the content
    ignored_lines: List[str] = []
    added: List[Path] = []
    modified: List[Path] = []
    removed: List[Path] = []

    for line in result.output.split("\n"):
        result = Repository.FileInfo.DecodeGitFileItemOutput(repository_root, line)

        if result is None:
            ignored_lines.append(line)
            continue

        # We don't care about working results here
        added_result, removed_result, modified_result, _ = result

        if added_result is not None:
            added.append(added_result)
        if removed_result is not None:
            removed.append(removed_result)
        if modified_result is not None:
            modified.append(modified_result)

    return _ParseGitOutputResultType(
        ignored_lines or None,
        added or None,
        modified or None,
        removed or None,
    )


# ----------------------------------------------------------------------
# ----------------------------------------------------------------------
# ----------------------------------------------------------------------
if __name__ == "__main__":
    app()
