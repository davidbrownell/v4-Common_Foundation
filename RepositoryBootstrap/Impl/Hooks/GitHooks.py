# ----------------------------------------------------------------------
# |
# |  GitHooks.py
# |
# |  David Brownell <db@DavidBrownell.com>
# |      2022-10-25 08:32:31
# |
# ----------------------------------------------------------------------
# |
# |  Copyright David Brownell 2022-23
# |  Distributed under the Boost Software License, Version 1.0. See
# |  accompanying file LICENSE_1_0.txt or copy at
# |  http://www.boost.org/LICENSE_1_0.txt.
# |
# ----------------------------------------------------------------------
"""Functionality invoked by Git hook scripts"""

import copy
import re
import textwrap
import sys

from contextlib import contextmanager
from dataclasses import dataclass
from pathlib import Path
from typing import Iterator, List, Optional, Tuple, Union

import typer

from typer.core import TyperGroup

from Common_Foundation.SourceControlManagers.GitSourceControlManager import GitSourceControlManager
from Common_Foundation.Streams.Capabilities import Capabilities
from Common_Foundation.Streams.DoneManager import DoneManager, DoneManagerFlags
from Common_Foundation import SubprocessEx
from Common_Foundation import TextwrapEx

from . import HookImpl


# ----------------------------------------------------------------------
class NaturalOrderGrouper(TyperGroup):
    # ----------------------------------------------------------------------
    def list_commands(self, *args, **kwargs):  # pylint: disable=unused-argument
        return self.commands.keys()


# ----------------------------------------------------------------------
app                                         = typer.Typer(
    cls=NaturalOrderGrouper,
    no_args_is_help=True,
    pretty_exceptions_show_locals=False,
    pretty_exceptions_enable=False,
)


# ----------------------------------------------------------------------
@app.command("prepare_commit_msg", no_args_is_help=True)
def prepare_commit_msg(
    working_dir: Path=typer.Argument(..., file_okay=False, exists=True, resolve_path=True, help="git working directory."),
    name: str=typer.Argument(..., help="git username."),
    email: str=typer.Argument(..., help="git email."),
    # Note that this filename is not resolved via typer due to the way in which the script is invoked.
    commit_message_file: Path=typer.Argument(..., dir_okay=False, help="File generated by git that contains the commit message."),
    commit_type: Optional[str]=typer.Argument(None, help="Type of commit."),
    extra_data: Optional[str]=typer.Argument(None, help="Extract data sometimes passed to this function, although its usefulness is not entirely clear."),
    verbose: bool=typer.Option(False, "--verbose", help="Write verbose information to the terminal."),
    debug: bool=typer.Option(False, "--debug", help="Write debug information to the terminal."),
) -> None:
    """Functionality invoked before the user is presented with an option to change the commit message."""

    with _YieldCommandLineDoneManager(verbose=verbose, debug=debug) as dm:
        if commit_type is not None and commit_type not in ["message", "commit"]:
            dm.WriteError("'{}' is a commit type not yet seen in the wild.".format(commit_type))

        if commit_type is None:
            calculated_commit_type = HookImpl.CommitInfo.CommitType.Squash
        elif commit_type in [
            "message",
            "template",  # I'm not sure why git wants to differentiate between these scenarios, as the contents of commit_message_file have been pre-populated with the contents of the template file
        ]:
            # GitKraken sends this type with a squash when extra_data is not None
            if extra_data is not None:
                calculated_commit_type = HookImpl.CommitInfo.CommitType.Squash
            else:
                calculated_commit_type = HookImpl.CommitInfo.CommitType.Standard
        elif commit_type == "commit":
            calculated_commit_type = HookImpl.CommitInfo.CommitType.Amend
        else:
            assert False, commit_type

        dm.WriteInfo(
            textwrap.dedent(
                """\
                prepare_commit_msg
                ------------------
                commit_message_file:        {}
                commit_type:                {}
                extra_data:                 {}

                calculated_commit_type:     {}

                """,
            ).format(
                commit_message_file,
                commit_type or "None",
                extra_data or "None",
                calculated_commit_type,
            ),
        )

        _OnCommitLikeChange(
            dm,
            working_dir,
            name,
            email,
            commit_message_file,
            calculated_commit_type,
            is_user_authored=False,
        )


# ----------------------------------------------------------------------
@app.command("commit_msg", no_args_is_help=True)
def commit_msg(
    working_dir: Path=typer.Argument(..., file_okay=False, exists=True, resolve_path=True, help="git working directory."),
    name: str=typer.Argument(..., help="git username."),
    email: str=typer.Argument(..., help="git email."),
    # Note that this filename is not resolved via typer due to the way in which the script is invoked.
    commit_message_file: Path=typer.Argument(..., dir_okay=False, help="File generated by git that contains the commit message."),
    verbose: bool=typer.Option(False, "--verbose", help="Write verbose information to the terminal."),
    debug: bool=typer.Option(False, "--debug", help="Write debug information to the terminal."),
) -> None:
    """Functionality invoked before a commit is finalized."""

    with _YieldCommandLineDoneManager(verbose=verbose, debug=debug) as dm:
        dm.WriteInfo(
            textwrap.dedent(
                """\
                commit_msg
                ----------
                commit_message_file:        {}

                """,
            ).format(
                commit_message_file,
            ),
        )

        _OnCommitLikeChange(
            dm,
            working_dir,
            name,
            email,
            commit_message_file,
            HookImpl.CommitInfo.CommitType.Standard,
            is_user_authored=True,
        )


# ----------------------------------------------------------------------
@app.command("pre_push", no_args_is_help=True)
def pre_push(
    working_dir: Path=typer.Argument(..., file_okay=False, exists=True, resolve_path=True, help="git working directory."),  # pylint: disable=unused-argument
    verbose: bool=typer.Option(False, "--verbose", help="Write verbose information to the terminal."),
    debug: bool=typer.Option(False, "--debug", help="Write debug information to the terminal."),
) -> None:
    """Functionality invoked before a set of changes are pushed to the remote repository."""

    with _YieldCommandLineDoneManager(verbose=verbose, debug=debug) as dm:
        dm.WriteError("Not implemented yet")


# ----------------------------------------------------------------------
@app.command("pre_receive", no_args_is_help=True)
def pre_receive(
    working_dir: Path=typer.Argument(..., file_okay=False, exists=True, resolve_path=True, help="git working directory."),  # pylint: disable=unused-argument
    verbose: bool=typer.Option(False, "--verbose", help="Write verbose information to the terminal."),
    debug: bool=typer.Option(False, "--debug", help="Write debug information to the terminal."),
) -> None:
    """Functionality invoked after a set of changes are received from a remote repository but before they are introduced into the current repository."""

    with _YieldCommandLineDoneManager(verbose=verbose, debug=debug) as dm:
        dm.WriteError("Not implemented yet")


# ----------------------------------------------------------------------
# |
# |  Private Types
# |
# ----------------------------------------------------------------------
@dataclass(frozen=True)
class _ExtractCommitMessageResult(object):
    title: str
    description: Optional[str]


# ----------------------------------------------------------------------
@dataclass(frozen=True)
class _ParseGitOutputResultType(object):
    # ----------------------------------------------------------------------
    ignored_lines: Optional[List[str]]
    files_added: Optional[List[Path]]
    files_modified: Optional[List[Path]]
    files_removed: Optional[List[Path]]

    # ----------------------------------------------------------------------
    def __post_init__(self):
        assert self.ignored_lines is None or self.ignored_lines
        assert self.files_added is None or self.files_added
        assert self.files_modified is None or self.files_modified
        assert self.files_removed is None or self.files_removed


# ----------------------------------------------------------------------
# |
# |  Private Functions
# |
# ----------------------------------------------------------------------
@contextmanager
def _YieldCommandLineDoneManager(
    *,
    verbose: bool,
    debug: bool,
) -> Iterator[DoneManager]:
    Capabilities.Create(
        sys.stdout,
        is_headless=False,
        supports_colors=True,
        # Make this look reasonable for most terminals
        columns=140,
        no_column_warning=True,
    )

    with DoneManager.CreateCommandLine(
        output_flags=DoneManagerFlags.Create(verbose=verbose, debug=debug),
    ) as dm:
        yield dm


# ----------------------------------------------------------------------
def _OnCommitLikeChange(
    dm: DoneManager,
    working_dir: Path,
    name: str,
    email: str,
    commit_message_file: Path,
    commit_type: HookImpl.CommitInfo.CommitType,
    *,
    is_user_authored: bool,
) -> None:
    git = GitSourceControlManager()

    repository = git.Open(git.GetRoot(working_dir))

    with dm.Nested("Extracting commit information...") as commit_dm:
        # Get the message info
        commit_message_file = working_dir / commit_message_file
        assert commit_message_file.is_file(), commit_message_file

        with commit_message_file.open(
            encoding="UTF-8",
        ) as f:
            message_content = f.read()

        message_lines = message_content.split("\n")

        title = message_lines[0]

        if len(message_lines) == 1:
            description = None
        else:
            message_line_index = 1

            if len(message_lines) > (message_line_index + 1) and not message_lines[message_line_index]:
                message_line_index += 1

            description = "\n".join(message_lines[message_line_index:])

        # Get the changed files
        commits: List[HookImpl.CommitInfo] = []

        if commit_type == HookImpl.CommitInfo.CommitType.Standard:
            working_info = _CreateWorkingCommitInfo(
                commit_dm,
                repository.repo_root,
                name,
                email,
                title,
                description,
                is_user_authored=is_user_authored,
            )

            if working_info is None:
                return

            commits.append(working_info)

        elif commit_type == HookImpl.CommitInfo.CommitType.Amend:
            working_info = _CreateWorkingCommitInfo(
                commit_dm,
                repository.repo_root,
                name,
                email,
                title,
                description,
                is_user_authored=is_user_authored,
            )

            if working_info is None:
                return

            commits.append(working_info)

            last_change_info = _CreateChangeCommitInfo(
                commit_dm,
                repository.repo_root,
                commit_type,
                -1,
                is_user_authored=is_user_authored,
            )

            if last_change_info is None:
                return

            commits.append(last_change_info)

        elif commit_type == HookImpl.CommitInfo.CommitType.Squash:
            # Unfortunately, once we are here, we don't seem to have the necessary context to figure
            # out which changes actually prompted the hook to be fired. Make due as best that we can
            # given the lack of information.
            commits.append(
                HookImpl.CommitInfo(
                    commit_type,
                    "<unknown>",
                    "{} <{}>".format(name, email),
                    title,
                    description,
                    None,
                    None,
                    None,
                    is_user_authored=is_user_authored,
                ),
            )

        else:
            assert False, commit_type

    assert commits

    original_commit_info = commits[0]

    if original_commit_info.commit_type == HookImpl.CommitInfo.CommitType.Standard:
        original_commit_info = copy.deepcopy(original_commit_info)

    HookImpl.Commit(dm, repository, commits)

    if commits[0] != original_commit_info:
        if commits[0].files_added != original_commit_info.files_added:
            raise Exception("Changes to files added is not supported yet")
        if commits[0].files_modified != original_commit_info.files_modified:
            raise Exception("Changes to files modified is not supported yet")
        if commits[0].files_removed != original_commit_info.files_removed:
            raise Exception("Changes to files removed is not supported yet")

        if (
            commits[0].title != original_commit_info.title
            or commits[0].description != original_commit_info.description
        ):
            new_message_content = commits[0].title

            if commits[0].description:
                new_message_content += "\n\n{}".format(commits[0].description)

            with commit_message_file.open(
                "w",
                encoding="UTF-8",
            ) as f:
                f.write(new_message_content)


# ----------------------------------------------------------------------
def _CreateWorkingCommitInfo(
    dm: DoneManager,
    repository_root: Path,
    name: str,
    email: str,
    title: str,
    description: Optional[str],
    *,
    is_user_authored: bool,
) -> Optional[HookImpl.CommitInfo]:
    result = _ParseGitOutput(
        dm,
        repository_root,
        "git status --porcelain=1 --untracked-files=no",
    )

    if result is None:
        assert dm.result != 0
        return None

    assert result.ignored_lines is None or all(not line for line in result.ignored_lines), result.ignored_lines

    return HookImpl.CommitInfo(
        HookImpl.CommitInfo.CommitType.Standard,
        "HEAD",
        "{} <{}>".format(name, email),
        title,
        description,
        result.files_added,
        result.files_modified,
        result.files_removed,
        is_user_authored=is_user_authored,
    )


# ----------------------------------------------------------------------
def _CreateChangeCommitInfo(
    dm: DoneManager,
    repository_root: Path,
    commit_type: HookImpl.CommitInfo.CommitType,
    change_id: Union[str, int],
    *,
    is_user_authored: bool,
) -> Optional[HookImpl.CommitInfo]:
    # Ensure that the change id is a string
    if not isinstance(change_id, str):
        result = SubprocessEx.Run(
            "git log {} --format=%H".format(change_id),
            cwd=repository_root,
        )

        dm.result = result.returncode

        if dm.result != 0:
            dm.WriteError(result.output)
            return None

        change_id = result.output.strip()

    result = _ParseGitOutput(
        dm,
        repository_root,
        "git show {} --name-status --no-color".format(change_id),
    )

    if result is None:
        assert dm.result != 0
        return None

    # Extract the rest of the commit info
    assert result.ignored_lines

    tag_value_regex = re.compile(
        r"""(?#
        Start of Line                       )^(?#
        Tag                                 )(?P<tag>\S+):(?#
        Value                               )\s*(?P<value>.+)(?#
        End of Line                         )$(?#
        )""",
    )

    description_regex = re.compile(
        r"""(?#
        Start of Line                       )^(?#
        Initial Whitespace                  )(?P<whitespace>\s+)(?#
        Content                             )(?P<content>\S.*?)(?#
        End of Line                         )$(?#
        )""",
    )

    author: Optional[str] = None
    title: Optional[str] = None
    description_whitespace_len: Optional[int] = None
    description_lines: List[str] = []
    in_description = False

    for line in result.ignored_lines:
        tag_value_match = tag_value_regex.match(line)
        if tag_value_match:
            tag = tag_value_match.group("tag")
            value = tag_value_match.group("value")

            if tag == "Author":
                assert author is None
                author = value

            in_description = False
            continue

        description_match = description_regex.match(line)
        if description_match:
            in_description = True

            whitespace = description_match.group("whitespace")
            content = description_match.group("content")

            if title is None:
                title = content

                assert description_whitespace_len is None
                description_whitespace_len = len(whitespace)
            else:
                description_lines.append(
                    "{}{}".format(
                        whitespace[description_whitespace_len:],
                        content,
                    ),
                )

            continue

        if in_description:
            description_lines.append("")
            continue

    if description_lines and not description_lines[0]:
        description_lines = description_lines[1:]

    assert author is not None
    assert title is not None

    return HookImpl.CommitInfo(
        commit_type,
        change_id,
        author,
        title,
        "\n".join(description_lines) if description_lines else None,
        result.files_added,
        result.files_modified,
        result.files_removed,
        is_user_authored=is_user_authored,
    )


# ----------------------------------------------------------------------
def _ParseGitOutput(
    dm: DoneManager,
    repository_root: Path,
    command_line: str,
) -> Optional[_ParseGitOutputResultType]:
    result = SubprocessEx.Run(
        command_line,
        cwd=repository_root,
    )

    dm.result = result.returncode

    if dm.result != 0:
        dm.WriteError(
            textwrap.dedent(
                """\
                {}

                {}
                """,
            ).format(
                command_line,
                TextwrapEx.Indent(result.output, 4),
            ),
        )

        return None

    output = result.output.rstrip()

    with dm.YieldVerboseStream() as stream:
        stream.write(
            textwrap.dedent(
                """\
                Command Line: {}

                {}


                """,
            ).format(
                command_line,
                TextwrapEx.Indent(output, 4),
            ),
        )

    # Parse the content
    ignored_lines: List[str] = []
    added: List[Path] = []
    modified: List[Path] = []
    removed: List[Path] = []

    # See https://git-scm.com/docs/git-status for more information on the porcelain output format
    status_regex = re.compile(r"^(?P<prefix_x>.)(?P<prefix_y>.)\s+(?P<filename>\S.*)$")
    show_regex = re.compile(r"^(?P<code>[RADCMTU])\s+(?P<filename>\S.*)$")

    # ----------------------------------------------------------------------
    def MatchLine(
        line: str,
    ) -> Optional[Tuple[Optional[str], str]]:
        status_match = status_regex.match(line)
        if status_match:
            prefix_x = status_match.group("prefix_x")
            prefix_y = status_match.group("prefix_y")

            if prefix_x.isspace() and prefix_y.isspace():
                # The status match has to be pretty greedy, as there can be spaces in the place of codes.
                # Account for the scenario where we have unintentionally matched a line with leading
                # whitespace (as can happen with commit descriptions).
                return None

            if prefix_x == " ":
                # This is an indication that the file has changed locally, but has not be added to this commit.
                # This is safe to ignore without added it to the ignored lines.
                prefix_x = None

            return prefix_x, status_match.group("filename")

        show_match = show_regex.match(line)
        if show_match:
            return show_match.group("code"), show_match.group("filename")

        return None

    # ----------------------------------------------------------------------

    for line in output.split("\n"):
        if "trace: " in line:
            continue

        match_result = MatchLine(line)
        if match_result is None:
            ignored_lines.append(line)
            continue

        code, filename = match_result

        if code is None:
            continue

        if code == "R":
            assert " -> " in filename, filename
            source, dest = filename.split(" -> ", maxsplit=1)

            removed.append(repository_root / source)
            added.append(repository_root / dest)
        elif code == "A":
            added.append(repository_root / filename)
        elif code == "D":
            removed.append(repository_root / filename)
        elif code in [
            "C", # Copied
            "M", # Modified
            "T", # Type changed
            "U", # Updated but unmerged
        ]:
            modified.append(repository_root / filename)
        else:
            assert False, line

    return _ParseGitOutputResultType(
        ignored_lines or None,
        added or None,
        modified or None,
        removed or None,
    )


# ----------------------------------------------------------------------
# ----------------------------------------------------------------------
# ----------------------------------------------------------------------
if __name__ == "__main__":
    app()
